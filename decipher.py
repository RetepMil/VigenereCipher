from collections import deque, defaultdict
import pprint
pp = pprint.PrettyPrinter(compact=True)

# 키 값에 따른 빠른 encryption을 위한 dictionary 초기화
key_strings = '''00 DTYLUKCNOIVSEPFQJWRGMBZAXH
01 LOGKWPRMDUVSYFJNTQIHEAZCBX
02 YGSKCJETRMUWNHQXIZFAOVBLDP
03 BERHJYKWCSLNPDZIGFUAOXVQTM
04 JLSGAOPZEMBVQCUIYDTHXRWFKN
05 IPWSURJTOQGEVDBMYKLNHAXZFC
06 CGLXSIBTJHOKNDMQPVRZAYEFUW
07 YGHKDVLQEXUOASZWPJFBCNRITM
08 ACZLSOGEDPYWFXHBVIMUKNTJQR
09 XTHNIBAFEUQSGLJDWOZKMPVCYR
10 MFKGNURPJZTBQWLCASIHVYOXDE
11 NHTEPCFDXRYZBAIMSGVJKUOQWL
12 AHFPGVUKLMNCTSRDEIWZXYQBOJ
13 SAHIKWDQJNPVUTZCBYLOGFMREX
14 GPNWMTOSQHJVYKFEALXCIRDBZU
15 GPCWQOSVZKINJHERUABDTMXLFY
16 NKAELXYVRDOGZIMTFUBSPJQHWC
17 EFTXLBCAWHUJGVOMYRSNKDQIZP
18 ZLNRQBAVYMJUDOTSHXCWGPKIEF
19 YAGDUTFIXMBWLOJQVNERHKSZPC
20 THRAWJEMNFKYZCIGOBXVSULDQP
21 INESDOMTPBQGHYFUZCRVWLKJXA
22 YIRAELHQOSXGCWTPJVZUNFMDKB
23 ITLFAXYCMOPVGZHURDBWNSJQKE
24 QRJGEFWVLKSUHPCXYBMOITNZAD
25 VYGNODPUJEMFCZIXASKBWHRTLQ
26 ANZIFPCLOKMHSJDEWVBYQXTURG
27 NEBZCRMKDPATGLSOWHFIJQVUYX
28 EQJTZFYSINAUBWCVDXRKHPLGMO
29 KDOTRBZWIAUYPLNHEGFQSJMCXV
30 XVSRDIUZFCQTMPLHYEGJAKNWOB
31 MVELIBQAFGJNPCKWXUSTZRDYHO
32 BMOITNEWDAUVPHZJXYSLRQCFGK
33 UYWVFPNHDCRSMZQGXOBTEKLAIJ
34 LBTNMCYODQIKHSFUJEVARPXWGZ
35 NFGUQPSTMCKOXJVWELIABRHYZD
36 CWMFKHPLOVIQXDARBUTEGZJSNY
37 ITOPAJWHEDZKMCVUXBYQSNLRGF
38 EODXLUVTSYHMFGAJNWPZQBCIKR
39 HZACTFNPIXMQRDUBYKVJOGWLES
40 KYFAZHCLPNQGXWDTVBORUJIMSE
41 NSWZTGXHKVBPCORLYQEAIJDFUM
42 XSYLMPKQIZWEANTOVHRDBFUCGJ
43 XYISKJVQMTRCAUNGZEOHFWLBDP
44 KDMEPYHGQZTSUVJFXOILRANBWC
45 GEVKJRNFBXWQPHDOAMTLIZYUCS
46 MZEKBDFIGQTLJPOWUXSHCRNYVA
47 AZLETRUFIPJHBXKOSYQMNGDCVW
48 KNEOJVXFQWCHTDGUMZLYSRAIPB
49 UIROVSWAGEQXTHZCFYLBDJPKMN
50 XBDQIFRUVENLHOAZPWGMKJTCSY
51 BPJZGEVCNTMAOIKHDWSRFUXQLY
52 CXEDARNFZGLSPWKQHTVIUBMOJY
53 IZMLCRNWAKTBUHJSPFOEGYQXDV
54 JOBCRSIAHGZKNYQLDFEPVXWMUT
55 WPCKJMQTZIELARUBSOXFVYHDNG
56 KHVUDGMOJWPYRFSQBLZACITNXE
57 VFIZLTQPMKRACDSOGJXEUNBWYH
58 GFYVTDQLHWJPKMBAZNIUOSCXER
59 QKMSFAZBVPHGWIODEXUCNYJLTR
60 IAPDHNYVFCMOERLUJTQBWSZXKG
61 ARZOWSMPBKJLVDGUIYNXFHCETQ
62 DHOXKZWVTCPBRMGIQALYJFUNES
63 TJFPRHKUWQOMXNIBLYVDZEAGSC
64 ACBZGTPNSJYDVLXRHOWKUEFMQI
65 FPHEOKUXNQMZWIVRTCSGBDLJAY
66 DJABIUXEYQOKRZNSLMPGCTVHFW
67 AIHDGCNLPQOVTKMJFSRZEBUYXW
68 JKULTOCZYWNDBIXHQMPSFGEARV
69 BZJTGQCFKWRPODNLYMSEVHIUAX
70 CQDBVGIZRNJKFLUXAWYTESPMOH
71 TADSIQMURKNHYVXCELWOPZGFJB
72 VSYUFWHJKOBNTIEDRXMLACZPGQ
73 ILCBVHDKSURWXJNFAEYOPQMGZT
74 WHVQOLDZPURMGEXTSFYBAICJKN
75 EZKTAMWIYJQXPLOVBCHNGUDFRS
76 VCLSBQWEDKGTYIFXHARMZUNPJO
77 FYAJDGSOVPRCHQWUNITEBKZLMX
78 BXQWVTCEURIZKAGPNLODFJHMYS
79 MJPKITCUYZSXBOGLADEWVFQNHR
80 IZEXRFDHAGSQNPTVBMLWKOUJCY
81 CTPONKGRMUJWQEYXZVALHIDBFS
82 HVFBTXSJLNAYPZUQOMRGWICKED
83 UCSBJDZOTEIQHARVYNWLPMGKFX
84 LUJHAXCWIRPMVDQNTGBZEFYOKS
85 AHUKMVEPFNBXYCTORQDSIWZGJL
86 XWLNYZGIAKJSURDHMQCETFVPBO
87 VSIJNAXHZLPOQYGRDKMUWFBETC
88 EMWOFAKYTNQZGXJPLVBRCIUDSH
89 RSLIHTMPNJXGOCKDUQFAZYWVBE
90 XCJIGNOKFEHMTADBYWPLSZRUQV
91 AJCKXTMLDWHEZBNYORUIVGPSQF
92 RZEWMCBXITNQLYADSOVGFUPHKJ
93 JMSOVGIPCLYUNDRTFEWQBHXKZA
94 FYCRPOJNHLSKVUBIDMXAEQZTGW
95 UXZRBFIQNYLWDKCHSJTPAVEGMO
96 SRJTMXUZBWGFYDKEVOPAHILQCN
97 QOHEWVDSTAKJIBNXPGCLRYMZFU
98 OKSGRZYCDEWVJPAHXFLIMUNBTQ
99 ULDOMNSRCYGVBPXQWAZJFKEITH'''
key_dict = {}
for key in key_strings.split('\n'):
    key, key_string = key.split(' ')
    
    temp_dict = defaultdict(list)
    for i in range(26):
        key_string_deque = deque(list(key_string))
        key_string_deque.rotate(-i)
        for j in range(26):
            temp_dict[key_string[i]].append(key_string_deque[j])
    
    key_dict[key] = temp_dict

plaintext  = 'THISCIPHERWASWIDELYUSEDBECAUSEOFSIMPLESTR'
ciphertext = 'OYKWUXRNJOOPPTXCTYNYQHFCQNIIWNKPAZQSTIFHOOWEYEHDQQYZMFQDHGZWUQIEZOUJNCEHDQQERBNJKRMRGLWIXVLVPFOBLLAVOPZENPADJPKVMMMPDYXJCBWEX'

'''
First determine length of k using sliding window
n이 1 부터 25까지 모든 offset 값을 하나씩 고려하면서, 각 n 자리마다 모두 치환가능한 key 후보군들이 전부 존재한다면 key의 길이를 구할 수 있다.
예를 들어 n이 4이면 4마다 등장하는 char에 대한 key_string은 동일해야 함:
plaintext에서 T...C...E..........E의 T, C, E는 모두 동일한 key_string을 사용해서 encryption됨

T C E ...
H I R ...
I P W ...
S H A ...

에서
T -> O, C -> U, E -> J,...에 해당하는 key_string과 offset의 pair가 존재함
'''

for n in range(1, 6):
    print(n)
    # groups에 residue of n 자리의 모든 문자를 하나의 그룹으로 묶어 놓는다
    groups = []
    for i in range(n):
        group = []
        cnt = i
        while cnt < len(plaintext) - 1:
            group.append((plaintext[cnt], ciphertext[cnt]))
            cnt += n
        groups.append(group)
    
    # groups에 대해서 위의 조건 검사 진행
    # possible_pair_per_group = []
    for i in range(1, 26): # offset 값
        pp.pprint(f'################# offset: {i} #################')
        for idx, group in enumerate(groups): # 각 residue 집합에 대해서 다음의 조건이 부합하는지 확인
            possible_key = []
            for j in range(0, 100):
                key = str(j) if j > 9 else f'0{j}'
                if all([ciphertext == key_dict[key][plaintext][i] for plaintext, ciphertext in group]):
                    possible_key.append(j)
            pp.pprint(str(idx) + " : " + str(possible_key) + ' , ' + str(group))


'''
살아남은 k 후보에 대해서 lingustic statistic analysis 실행
'''

a = 'CRYPTO'
keys = ['66', '11', '52', '55', '04', '90']
offset = 11
for plain_char, key in zip(a, keys):
    print(key_dict[key][plain_char][offset])